<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Unicorn Ranch</title>
<meta name="description" content="Keep the unicorn's needs filled to level up!" />
<link rel="icon" type="image/png" href="favicon.png">
<style>
  :root{
    --sky1:#9fd3ff; --sky2:#cfe8ff; --grass:#b8e986; --water:#9fd3ff;
    --barn1:#f77; --barn2:#d26; --dirt:#e2c39a;
    --uiScale: 1; /* desktop/tablet base */
  }

  /* Phones: make everything MUCH larger */
  @media (max-width: 640px){
    :root{ --uiScale: 10; }
  }

  /* Page */
  html,body{ margin:0; height:100%; background:linear-gradient(var(--sky1),var(--sky2) 30%,var(--grass) 30%); }
  body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
  #app{ min-height:100dvh; display:flex; justify-content:center; padding:8px; padding-bottom:calc(8px + env(safe-area-inset-bottom)); }

  /* World = column: UI on top, 2×2 grid fills remaining space */
  .world{
    display:flex; flex-direction:column;
    width:100%; max-width:1100px;
    height:100dvh;
    border-radius:24px; overflow:hidden;
    box-shadow:0 10px 40px rgba(0,0,0,.15);
    background:linear-gradient(var(--sky1),var(--sky2) 35%, var(--grass) 35%);
    position:relative;  
  }

  /* Top UI */
  .ui{
    padding:calc(8px * var(--uiScale));
    background:rgba(255,255,255,.92);
    display:flex; flex-direction:column; gap:calc(10px * var(--uiScale));
    z-index:2;
  }
  .row{ display:flex; flex-wrap:wrap; gap:calc(10px * var(--uiScale)); align-items:center; }
  .pill{ display:inline-flex; align-items:center; gap:calc(8px * var(--uiScale));
         padding:calc(6px * var(--uiScale)) calc(12px * var(--uiScale));
         border-radius:999px; background:#fff; font-weight:700;
         font-size:calc(clamp(12px, 1.8vw, 16px) * var(--uiScale)); }
  .btn{ cursor:pointer; padding:calc(8px * var(--uiScale)) calc(14px * var(--uiScale));
        border-radius:12px; border:none; font-weight:700;
        font-size:calc(clamp(12px, 1.8vw, 16px) * var(--uiScale)); }
  .btn:active{ transform:translateY(1px); }
  .btn-green{ background:#4caf50; color:#fff; }
  .btn-green:hover{ background:#45a049; }
  .btn-blue{ background:#2196f3; color:#fff; }
  .btn-blue:hover{ background:#1976d2; }
  .btn-grey{ background:#888; color:#fff; }
  .btn-grey:hover{ background:#777; }
  .btn-donate{ background:#2d5a2d; color:#fff; }
  .btn-donate:hover{ background:#1a4d1a; }

  /* Bars: light grey track, black fill (red under 50%) */
  .meters{ display:flex; gap:calc(10px * var(--uiScale)); flex-wrap:wrap; }
  .meter{ width:clamp(160px, calc(28vw * var(--uiScale)), 320px);
          height:clamp(12px, calc(2.2vh * var(--uiScale)), 20px);
          background:#d3d3d3; border-radius:20px; overflow:hidden; }
  .fill{ display:block; height:100%; transition:width .15s linear, background-color .15s linear; }

  /* On phones: make bars take ~one third of screen vertically */
  @media (max-width: 640px){
    .meters{ flex-direction:column; align-items:stretch; min-height:33vh; }
    .meter{ width:100%; height:6.5vh; min-height:44px; }
  }

  /* Grid (2×2) fills the rest */
  .grid{
    flex:1; display:grid;
    grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr;
    gap:clamp(8px, calc(2vmin * var(--uiScale)), 24px);
    padding:calc(8px * var(--uiScale));
  }
  .zone{ position:relative; border-radius:20px; outline:4px solid rgba(255,255,255,.6); overflow:hidden; }
  .label{ position:absolute; top:8px; left:8px;
          padding:calc(6px * var(--uiScale)) calc(10px * var(--uiScale));
          background:rgba(255,255,255,.9); border-radius:12px; font-weight:700;
          font-size:calc(clamp(12px, 1.8vw, 16px) * var(--uiScale)); z-index:2; }
  .lake{ background:radial-gradient(circle at 40% 30%, #e7f6ff, var(--water)); }
  .field{ background:repeating-linear-gradient(45deg, rgba(255,255,255,.35), rgba(255,255,255,.35) 10px, transparent 10px, transparent 20px); }
  .play{ background:linear-gradient(135deg, #fef3bd, #ffd6a5); }
  .barn{ background:linear-gradient(var(--barn1), var(--barn2)); }
  .barn .door{ position:absolute; left:50%; bottom:0; transform:translateX(-50%);
               width:28%; height:60%; background:#4b8a16; border:6px solid #2f2614;
               border-bottom:none; border-radius:10px 10px 0 0; }
  .barn .stoop{ position:absolute; left:14%; right:14%; bottom:-8%; height:14%;
                background:var(--dirt); border-radius:20px; }

  /* Unicorn (absolute in world) */
  .unicorn{
    position:absolute; aspect-ratio:1/1; user-select:none; touch-action:none; z-index:3;
    transform:translate(-50%,-50%);
    width:clamp(72px, calc(12vmin * var(--uiScale)), 160px);
  }
  .u-emoji{ font-size:clamp(48px, calc(8vmin * var(--uiScale)), 80px); line-height:1; }

  /* Phones: lock to "thumbnail" size so it doesn't overgrow */
  @media (max-width: 640px){
    .unicorn{ width:96px; }
    .u-emoji{ font-size:90px; }
  }

  /* Monster chases with CSS transitions to the unicorn's position */
  .monster{
    position:absolute; z-index:4; line-height:1; pointer-events:none;
    transform:translate(-50%,-50%) scale(1);
    transition: left 2s linear, top 2s linear, transform .25s ease;
    filter:hue-rotate(90deg) saturate(0.6) brightness(0.85); /* grey-green tint */
    font-size:clamp(72px, calc(14vmin * var(--uiScale)), 160px);
  }
  .monster.chomp{ transform:translate(-50%,-50%) scale(1.2) rotate(5deg); }

  /* Phones: monster = large thumbnail */
  @media (max-width: 640px){
    .monster{ font-size:110px; }
  }

  /* Modal */
  .modal{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.5); z-index:5; }
  .panel{ background:#fff; padding:calc(18px * var(--uiScale)); border-radius:16px; width:min(92%,520px); text-align:center; }
  .panel h2{ margin:0 0 12px; font-size:calc(clamp(18px, 3.2vmin, 22px) * var(--uiScale)); }
  .panel p{ margin:0 0 16px; font-size:calc(clamp(14px, 2.6vmin, 18px) * var(--uiScale)); }
</style>
</head>
<body>
<div id="app"></div>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
const {useState,useRef,useEffect} = React;
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

/* Base drain rates */
const BASE_DRAIN    = { hunger: 1.0, thirst: 1.0, energy: 1.0, fun: 1.0 };
const BASE_RECHARGE = { lake: {thirst: 6}, field: {hunger: 6}, barn: {energy: 8}, play: {fun: 6} };

/* Drain increase rates per level */
const DRAIN_GROWTH    = 0.80;  // drain +80% per level
const RECHARGE_GROWTH = 0.30;  // recharge +30% per level

function App(){
  const initial={
    x:15, y:25,
    needs:{hunger:100,thirst:100,energy:100,fun:100},
    level:1,
    levelTime:30,
    status:null,          // 'gameover' | 'nextlevel' | null
    eaten:false,          // monster sequence active
    monster:{ x:-20, y:50, chomp:false } // in %
  };

  const [s,setS]=useState(initial);
  const [dragging,setDragging]=useState(false);
  const worldRef=useRef(null);

  const drainMult    = 1 + (s.level-1)*DRAIN_GROWTH;
  const rechargeMult = 1 + (s.level-1)*RECHARGE_GROWTH;

  /* Main loop @10Hz */
  useEffect(()=>{
    if(s.status) return;
    const dt = 0.1;
    const id = setInterval(()=>{
      setS(prev=>{
        if(prev.status) return prev;

        const current = hitZoneAtPercent(prev.x, prev.y);

        const needs = {...prev.needs};
        // drain
        needs.hunger = clamp(needs.hunger - BASE_DRAIN.hunger*drainMult*dt, 0, 100);
        needs.thirst = clamp(needs.thirst - BASE_DRAIN.thirst*drainMult*dt, 0, 100);
        needs.energy = clamp(needs.energy - BASE_DRAIN.energy*drainMult*dt, 0, 100);
        needs.fun    = clamp(needs.fun    - BASE_DRAIN.fun   *drainMult*dt, 0, 100);

        // recharge (matching zone only)
        if(current==='lake')  needs.thirst = clamp(needs.thirst + BASE_RECHARGE.lake.thirst  *rechargeMult*dt, 0, 100);
        if(current==='field') needs.hunger = clamp(needs.hunger + BASE_RECHARGE.field.hunger*rechargeMult*dt, 0, 100);
        if(current==='barn')  needs.energy = clamp(needs.energy + BASE_RECHARGE.barn.energy *rechargeMult*dt, 0, 100);
        if(current==='play')  needs.fun    = clamp(needs.fun    + BASE_RECHARGE.play.fun    *rechargeMult*dt, 0, 100);

        // trigger monster sequence once
        if(Object.values(needs).some(v=>v<=0) && !prev.eaten){
          const startY = prev.y; // monster enters at unicorn's Y
          return {...prev, needs, eaten:true, monster:{ x:-20, y:startY, chomp:false }};
        }

        // countdown
        const time = prev.levelTime - dt;
        if(time <= 0){
          return {...prev, needs, levelTime:0, status:'nextlevel'};
        }
        return {...prev, needs, levelTime:time};
      });
    }, dt*1000);
    return ()=>clearInterval(id);
  },[s.status, s.level, s.eaten]);

  /* Monster chase + collision sequence */
  useEffect(()=>{
    if(!s.eaten) return;

    // Move monster to unicorn's current % position (2s)
    const chaseTimer = setTimeout(()=>{
      setS(prev=>({...prev, monster:{ ...prev.monster, x: prev.x, y: prev.y }}));
    }, 100);

    // Chomp near arrival (~2.1s), quick scale/tilt
    const chompTimer = setTimeout(()=>{
      setS(prev=>({...prev, monster:{...prev.monster, chomp:true}}));
    }, 2100);

    // After 4s total, show game over modal
    const overTimer = setTimeout(()=>{
      setS(prev=>({...prev, status:'gameover'}));
    }, 4000);

    return ()=>{ clearTimeout(chaseTimer); clearTimeout(chompTimer); clearTimeout(overTimer); };
  },[s.eaten]);

  /* Pointer to % helpers */
  function posToPercent(e){
    const r=worldRef.current.getBoundingClientRect();
    const xClient = (e.touches?.[0]) ? e.touches[0].clientX : e.clientX;
    const yClient = (e.touches?.[0]) ? e.touches[0].clientY : e.clientY;
    const cx = xClient - r.left;
    const cy = yClient - r.top;
    return {x:clamp((cx/r.width)*100,0,100), y:clamp((cy/r.height)*100,0,100)};
  }
  function onStart(e){ e.preventDefault(); if(s.eaten||s.status) return; setDragging(true); const {x,y}=posToPercent(e); setS(p=>({...p,x,y})); }
  function onMove(e){ if(!dragging || s.eaten || s.status) return; e.preventDefault(); const {x,y}=posToPercent(e); setS(p=>({...p,x,y})); }
  function onEnd(){ setDragging(false); }

  /* Zone detection in world % coords */
  function hitZoneAtPercent(xPct, yPct){
    if(!worldRef.current) return null;
    const rWorld=worldRef.current.getBoundingClientRect();
    const px=rWorld.left + (xPct/100)*rWorld.width;
    const py=rWorld.top  + (yPct/100)*rWorld.height;
    const els=[...worldRef.current.querySelectorAll('.grid > .zone')];
    for(const el of els){
      const rr=el.getBoundingClientRect();
      if(px>rr.left && px<rr.right && py>rr.top && py<rr.bottom){
        if(el.classList.contains('lake')) return 'lake';
        if(el.classList.contains('field')) return 'field';
        if(el.classList.contains('play')) return 'play';
        if(el.classList.contains('barn')) return 'barn';
      }
    }
    return null;
  }

  function restartGame(){ setS({...initial}); }
  function startNextLevel(){
    setS(prev=>({
      ...prev,
      level: prev.level + 1,
      needs:{hunger:100,thirst:100,energy:100,fun:100},
      levelTime:30,
      status:null,
      eaten:false,
      monster:{ x:-20, y:50, chomp:false }
    }));
  }

  const currentZone = hitZoneAtPercent(s.x, s.y);

  return (
    <div className="world" ref={worldRef}
         onMouseMove={onMove} onMouseUp={onEnd}
         onTouchMove={onMove} onTouchEnd={onEnd}>
      {/* UI */}
      <div className="ui">
        <div className="row">
          <span className="pill">Level: {s.level}</span>
          <span className="pill">Time: {Math.ceil(s.levelTime)}s</span>
          {currentZone && <span className="pill">
            Here: {currentZone==='lake'?'Lake 💧':currentZone==='field'?'Field 🍎':currentZone==='barn'?'Barn 💤':'Play 🎈'}
          </span>}
          <button className="btn btn-grey" onClick={restartGame}>Restart Game</button>
          <button className="btn btn-donate" onClick={()=>window.open('https://donate.stripe.com/00wfZhbnj5gAepS5CN33W00', '_blank')}>Donate Now!</button> {/* Stripe donation button */} 
        </div>   

        <div className="row meters">
          {Object.entries({hunger:"🍎",thirst:"💧",energy:"💤",fun:"🎈"}).map(([k,em])=>{
            const v=s.needs[k];
            const color = v<50 ? 'red' : 'black';
            return (
              <span className="pill" key={k}>
                <span aria-hidden="true" style={{fontSize:"1.25em"}}>{em}</span>
                <span className="meter">
                  <span className="fill" style={{width:`${v}%`, backgroundColor: color}}></span>
                </span>
              </span>
            );
          })}
        </div>
      </div>

      {/* 2×2 Grid */}
      <div className="grid">
        <div className="zone lake"><div className="label">Lake 💧</div></div>
        <div className="zone barn"><div className="label">Barn 💤</div><div className="door"></div><div className="stoop"></div></div>
        <div className="zone field"><div className="label">Field 🍎</div></div>
        <div className="zone play"><div className="label">Play 🎈</div></div>
      </div>

      {/* Unicorn (hidden once monster sequence triggers) */}
      {!s.eaten && (
        <div className="unicorn" style={{left:`${s.x}%`, top:`${s.y}%`}}
             onMouseDown={onStart} onTouchStart={onStart}>
          <div className="u-emoji">🦄</div>
        </div>
      )}

      {/* Monster goes to the unicorn and chomps */}
      {s.eaten && (
        <div className={`monster ${s.monster.chomp ? 'chomp' : ''}`}
             style={{ left:`${s.monster.x}%`, top:`${s.monster.y}%` }}>
          👹
        </div>
      )}

      {/* Modals */}
      {s.status==='gameover' && (
        <div className="modal">
          <div className="panel">
            <h2>Game over! Try again!</h2>
            <p>You reached level {s.level}.</p>
            <button className="btn btn-green" onClick={restartGame}>Restart</button>
          </div>
        </div>
      )}
      {s.status==='nextlevel' && (
        <div className="modal">
          <div className="panel">
            <h2>Congrats! You're going to the next level</h2>
            <p>Bars will drain and recharge faster every level!</p>
            <button className="btn btn-blue" onClick={startNextLevel}>Start Level {s.level+1}</button>
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('app')).render(<App/>);
</script>
</body>
</html>
